"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/match-sorter";
exports.ids = ["vendor-chunks/match-sorter"];
exports.modules = {

/***/ "(ssr)/../node_modules/match-sorter/dist/match-sorter.esm.js":
/*!*************************************************************!*\
  !*** ../node_modules/match-sorter/dist/match-sorter.esm.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultBaseSortFn: () => (/* binding */ defaultBaseSortFn),\n/* harmony export */   matchSorter: () => (/* binding */ matchSorter),\n/* harmony export */   rankings: () => (/* binding */ rankings)\n/* harmony export */ });\n/* harmony import */ var remove_accents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! remove-accents */ \"(ssr)/../node_modules/remove-accents/index.js\");\n/* harmony import */ var remove_accents__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(remove_accents__WEBPACK_IMPORTED_MODULE_0__);\n\n/**\r\n * @name match-sorter\r\n * @license MIT license.\r\n * @copyright (c) 2020 Kent C. Dodds\r\n * @author Kent C. Dodds <me@kentcdodds.com> (https://kentcdodds.com)\r\n */ const rankings = {\n    CASE_SENSITIVE_EQUAL: 7,\n    EQUAL: 6,\n    STARTS_WITH: 5,\n    WORD_STARTS_WITH: 4,\n    CONTAINS: 3,\n    ACRONYM: 2,\n    MATCHES: 1,\n    NO_MATCH: 0\n};\nconst defaultBaseSortFn = (a, b)=>String(a.rankedValue).localeCompare(String(b.rankedValue));\n/**\r\n * Takes an array of items and a value and returns a new array with the items that match the given value\r\n * @param {Array} items - the items to sort\r\n * @param {String} value - the value to use for ranking\r\n * @param {Object} options - Some options to configure the sorter\r\n * @return {Array} - the new sorted array\r\n */ function matchSorter(items, value, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { keys, threshold = rankings.MATCHES, baseSort = defaultBaseSortFn, sorter = (matchedItems)=>matchedItems.sort((a, b)=>sortRankedValues(a, b, baseSort)) } = options;\n    const matchedItems = items.reduce(reduceItemsToRanked, []);\n    return sorter(matchedItems).map((_ref)=>{\n        let { item } = _ref;\n        return item;\n    });\n    function reduceItemsToRanked(matches, item, index) {\n        const rankingInfo = getHighestRanking(item, keys, value, options);\n        const { rank, keyThreshold = threshold } = rankingInfo;\n        if (rank >= keyThreshold) {\n            matches.push({\n                ...rankingInfo,\n                item,\n                index\n            });\n        }\n        return matches;\n    }\n}\nmatchSorter.rankings = rankings;\n/**\r\n * Gets the highest ranking for value for the given item based on its values for the given keys\r\n * @param {*} item - the item to rank\r\n * @param {Array} keys - the keys to get values from the item for the ranking\r\n * @param {String} value - the value to rank against\r\n * @param {Object} options - options to control the ranking\r\n * @return {{rank: Number, keyIndex: Number, keyThreshold: Number}} - the highest ranking\r\n */ function getHighestRanking(item, keys, value, options) {\n    if (!keys) {\n        // if keys is not specified, then we assume the item given is ready to be matched\n        const stringItem = item;\n        return {\n            // ends up being duplicate of 'item' in matches but consistent\n            rankedValue: stringItem,\n            rank: getMatchRanking(stringItem, value, options),\n            keyIndex: -1,\n            keyThreshold: options.threshold\n        };\n    }\n    const valuesToRank = getAllValuesToRank(item, keys);\n    return valuesToRank.reduce((_ref2, _ref3, i)=>{\n        let { rank, rankedValue, keyIndex, keyThreshold } = _ref2;\n        let { itemValue, attributes } = _ref3;\n        let newRank = getMatchRanking(itemValue, value, options);\n        let newRankedValue = rankedValue;\n        const { minRanking, maxRanking, threshold } = attributes;\n        if (newRank < minRanking && newRank >= rankings.MATCHES) {\n            newRank = minRanking;\n        } else if (newRank > maxRanking) {\n            newRank = maxRanking;\n        }\n        if (newRank > rank) {\n            rank = newRank;\n            keyIndex = i;\n            keyThreshold = threshold;\n            newRankedValue = itemValue;\n        }\n        return {\n            rankedValue: newRankedValue,\n            rank,\n            keyIndex,\n            keyThreshold\n        };\n    }, {\n        rankedValue: item,\n        rank: rankings.NO_MATCH,\n        keyIndex: -1,\n        keyThreshold: options.threshold\n    });\n}\n/**\r\n * Gives a rankings score based on how well the two strings match.\r\n * @param {String} testString - the string to test against\r\n * @param {String} stringToRank - the string to rank\r\n * @param {Object} options - options for the match (like keepDiacritics for comparison)\r\n * @returns {Number} the ranking for how well stringToRank matches testString\r\n */ function getMatchRanking(testString, stringToRank, options) {\n    testString = prepareValueForComparison(testString, options);\n    stringToRank = prepareValueForComparison(stringToRank, options);\n    // too long\n    if (stringToRank.length > testString.length) {\n        return rankings.NO_MATCH;\n    }\n    // case sensitive equals\n    if (testString === stringToRank) {\n        return rankings.CASE_SENSITIVE_EQUAL;\n    }\n    // Lower casing before further comparison\n    testString = testString.toLowerCase();\n    stringToRank = stringToRank.toLowerCase();\n    // case insensitive equals\n    if (testString === stringToRank) {\n        return rankings.EQUAL;\n    }\n    // starts with\n    if (testString.startsWith(stringToRank)) {\n        return rankings.STARTS_WITH;\n    }\n    // word starts with\n    if (testString.includes(` ${stringToRank}`)) {\n        return rankings.WORD_STARTS_WITH;\n    }\n    // contains\n    if (testString.includes(stringToRank)) {\n        return rankings.CONTAINS;\n    } else if (stringToRank.length === 1) {\n        // If the only character in the given stringToRank\n        //   isn't even contained in the testString, then\n        //   it's definitely not a match.\n        return rankings.NO_MATCH;\n    }\n    // acronym\n    if (getAcronym(testString).includes(stringToRank)) {\n        return rankings.ACRONYM;\n    }\n    // will return a number between rankings.MATCHES and\n    // rankings.MATCHES + 1 depending  on how close of a match it is.\n    return getClosenessRanking(testString, stringToRank);\n}\n/**\r\n * Generates an acronym for a string.\r\n *\r\n * @param {String} string the string for which to produce the acronym\r\n * @returns {String} the acronym\r\n */ function getAcronym(string) {\n    let acronym = \"\";\n    const wordsInString = string.split(\" \");\n    wordsInString.forEach((wordInString)=>{\n        const splitByHyphenWords = wordInString.split(\"-\");\n        splitByHyphenWords.forEach((splitByHyphenWord)=>{\n            acronym += splitByHyphenWord.substr(0, 1);\n        });\n    });\n    return acronym;\n}\n/**\r\n * Returns a score based on how spread apart the\r\n * characters from the stringToRank are within the testString.\r\n * A number close to rankings.MATCHES represents a loose match. A number close\r\n * to rankings.MATCHES + 1 represents a tighter match.\r\n * @param {String} testString - the string to test against\r\n * @param {String} stringToRank - the string to rank\r\n * @returns {Number} the number between rankings.MATCHES and\r\n * rankings.MATCHES + 1 for how well stringToRank matches testString\r\n */ function getClosenessRanking(testString, stringToRank) {\n    let matchingInOrderCharCount = 0;\n    let charNumber = 0;\n    function findMatchingCharacter(matchChar, string, index) {\n        for(let j = index, J = string.length; j < J; j++){\n            const stringChar = string[j];\n            if (stringChar === matchChar) {\n                matchingInOrderCharCount += 1;\n                return j + 1;\n            }\n        }\n        return -1;\n    }\n    function getRanking(spread) {\n        const spreadPercentage = 1 / spread;\n        const inOrderPercentage = matchingInOrderCharCount / stringToRank.length;\n        const ranking = rankings.MATCHES + inOrderPercentage * spreadPercentage;\n        return ranking;\n    }\n    const firstIndex = findMatchingCharacter(stringToRank[0], testString, 0);\n    if (firstIndex < 0) {\n        return rankings.NO_MATCH;\n    }\n    charNumber = firstIndex;\n    for(let i = 1, I = stringToRank.length; i < I; i++){\n        const matchChar = stringToRank[i];\n        charNumber = findMatchingCharacter(matchChar, testString, charNumber);\n        const found = charNumber > -1;\n        if (!found) {\n            return rankings.NO_MATCH;\n        }\n    }\n    const spread = charNumber - firstIndex;\n    return getRanking(spread);\n}\n/**\r\n * Sorts items that have a rank, index, and keyIndex\r\n * @param {Object} a - the first item to sort\r\n * @param {Object} b - the second item to sort\r\n * @return {Number} -1 if a should come first, 1 if b should come first, 0 if equal\r\n */ function sortRankedValues(a, b, baseSort) {\n    const aFirst = -1;\n    const bFirst = 1;\n    const { rank: aRank, keyIndex: aKeyIndex } = a;\n    const { rank: bRank, keyIndex: bKeyIndex } = b;\n    const same = aRank === bRank;\n    if (same) {\n        if (aKeyIndex === bKeyIndex) {\n            // use the base sort function as a tie-breaker\n            return baseSort(a, b);\n        } else {\n            return aKeyIndex < bKeyIndex ? aFirst : bFirst;\n        }\n    } else {\n        return aRank > bRank ? aFirst : bFirst;\n    }\n}\n/**\r\n * Prepares value for comparison by stringifying it, removing diacritics (if specified)\r\n * @param {String} value - the value to clean\r\n * @param {Object} options - {keepDiacritics: whether to remove diacritics}\r\n * @return {String} the prepared value\r\n */ function prepareValueForComparison(value, _ref4) {\n    let { keepDiacritics } = _ref4;\n    // value might not actually be a string at this point (we don't get to choose)\n    // so part of preparing the value for comparison is ensure that it is a string\n    value = `${value}`; // toString\n    if (!keepDiacritics) {\n        value = remove_accents__WEBPACK_IMPORTED_MODULE_0___default()(value);\n    }\n    return value;\n}\n/**\r\n * Gets value for key in item at arbitrarily nested keypath\r\n * @param {Object} item - the item\r\n * @param {Object|Function} key - the potentially nested keypath or property callback\r\n * @return {Array} - an array containing the value(s) at the nested keypath\r\n */ function getItemValues(item, key) {\n    if (typeof key === \"object\") {\n        key = key.key;\n    }\n    let value;\n    if (typeof key === \"function\") {\n        value = key(item);\n    } else if (item == null) {\n        value = null;\n    } else if (Object.hasOwnProperty.call(item, key)) {\n        value = item[key];\n    } else if (key.includes(\".\")) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n        return getNestedValues(key, item);\n    } else {\n        value = null;\n    }\n    // because `value` can also be undefined\n    if (value == null) {\n        return [];\n    }\n    if (Array.isArray(value)) {\n        return value;\n    }\n    return [\n        String(value)\n    ];\n}\n/**\r\n * Given path: \"foo.bar.baz\"\r\n * And item: {foo: {bar: {baz: 'buzz'}}}\r\n *   -> 'buzz'\r\n * @param path a dot-separated set of keys\r\n * @param item the item to get the value from\r\n */ function getNestedValues(path, item) {\n    const keys = path.split(\".\");\n    let values = [\n        item\n    ];\n    for(let i = 0, I = keys.length; i < I; i++){\n        const nestedKey = keys[i];\n        let nestedValues = [];\n        for(let j = 0, J = values.length; j < J; j++){\n            const nestedItem = values[j];\n            if (nestedItem == null) continue;\n            if (Object.hasOwnProperty.call(nestedItem, nestedKey)) {\n                const nestedValue = nestedItem[nestedKey];\n                if (nestedValue != null) {\n                    nestedValues.push(nestedValue);\n                }\n            } else if (nestedKey === \"*\") {\n                // ensure that values is an array\n                nestedValues = nestedValues.concat(nestedItem);\n            }\n        }\n        values = nestedValues;\n    }\n    if (Array.isArray(values[0])) {\n        // keep allowing the implicit wildcard for an array of strings at the end of\n        // the path; don't use `.flat()` because that's not available in node.js v10\n        const result = [];\n        return result.concat(...values);\n    }\n    // Based on our logic it should be an array of strings by now...\n    // assuming the user's path terminated in strings\n    return values;\n}\n/**\r\n * Gets all the values for the given keys in the given item and returns an array of those values\r\n * @param item - the item from which the values will be retrieved\r\n * @param keys - the keys to use to retrieve the values\r\n * @return objects with {itemValue, attributes}\r\n */ function getAllValuesToRank(item, keys) {\n    const allValues = [];\n    for(let j = 0, J = keys.length; j < J; j++){\n        const key = keys[j];\n        const attributes = getKeyAttributes(key);\n        const itemValues = getItemValues(item, key);\n        for(let i = 0, I = itemValues.length; i < I; i++){\n            allValues.push({\n                itemValue: itemValues[i],\n                attributes\n            });\n        }\n    }\n    return allValues;\n}\nconst defaultKeyAttributes = {\n    maxRanking: Infinity,\n    minRanking: -Infinity\n};\n/**\r\n * Gets all the attributes for the given key\r\n * @param key - the key from which the attributes will be retrieved\r\n * @return object containing the key's attributes\r\n */ function getKeyAttributes(key) {\n    if (typeof key === \"string\") {\n        return defaultKeyAttributes;\n    }\n    return {\n        ...defaultKeyAttributes,\n        ...key\n    };\n}\n/*\r\neslint\r\n  no-continue: \"off\",\r\n*/ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL21hdGNoLXNvcnRlci9kaXN0L21hdGNoLXNvcnRlci5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBMkM7QUFFM0M7Ozs7O0NBS0MsR0FDRCxNQUFNQyxXQUFXO0lBQ2ZDLHNCQUFzQjtJQUN0QkMsT0FBTztJQUNQQyxhQUFhO0lBQ2JDLGtCQUFrQjtJQUNsQkMsVUFBVTtJQUNWQyxTQUFTO0lBQ1RDLFNBQVM7SUFDVEMsVUFBVTtBQUNaO0FBQ0EsTUFBTUMsb0JBQW9CLENBQUNDLEdBQUdDLElBQU1DLE9BQU9GLEVBQUVHLFdBQVcsRUFBRUMsYUFBYSxDQUFDRixPQUFPRCxFQUFFRSxXQUFXO0FBRTVGOzs7Ozs7Q0FNQyxHQUNELFNBQVNFLFlBQVlDLEtBQUssRUFBRUMsS0FBSyxFQUFFQyxPQUFPO0lBQ3hDLElBQUlBLFlBQVksS0FBSyxHQUFHO1FBQ3RCQSxVQUFVLENBQUM7SUFDYjtJQUNBLE1BQU0sRUFDSkMsSUFBSSxFQUNKQyxZQUFZcEIsU0FBU08sT0FBTyxFQUM1QmMsV0FBV1osaUJBQWlCLEVBQzVCYSxTQUFTQyxDQUFBQSxlQUFnQkEsYUFBYUMsSUFBSSxDQUFDLENBQUNkLEdBQUdDLElBQU1jLGlCQUFpQmYsR0FBR0MsR0FBR1UsVUFBVSxFQUN2RixHQUFHSDtJQUNKLE1BQU1LLGVBQWVQLE1BQU1VLE1BQU0sQ0FBQ0MscUJBQXFCLEVBQUU7SUFDekQsT0FBT0wsT0FBT0MsY0FBY0ssR0FBRyxDQUFDQyxDQUFBQTtRQUM5QixJQUFJLEVBQ0ZDLElBQUksRUFDTCxHQUFHRDtRQUNKLE9BQU9DO0lBQ1Q7SUFDQSxTQUFTSCxvQkFBb0JJLE9BQU8sRUFBRUQsSUFBSSxFQUFFRSxLQUFLO1FBQy9DLE1BQU1DLGNBQWNDLGtCQUFrQkosTUFBTVgsTUFBTUYsT0FBT0M7UUFDekQsTUFBTSxFQUNKaUIsSUFBSSxFQUNKQyxlQUFlaEIsU0FBUyxFQUN6QixHQUFHYTtRQUNKLElBQUlFLFFBQVFDLGNBQWM7WUFD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O0lBQ0Y7SUFDQSxPQUFPK0Q7QUFDVDtBQUNBLE1BQU1HLHVCQUF1QjtJQUMzQjlELFlBQVkrRDtJQUNaaEUsWUFBWSxDQUFDZ0U7QUFDZjtBQUNBOzs7O0NBSUMsR0FDRCxTQUFTSCxpQkFBaUJoQixHQUFHO0lBQzNCLElBQUksT0FBT0EsUUFBUSxVQUFVO1FBQzNCLE9BQU9rQjtJQUNUO0lBQ0EsT0FBTztRQUNMLEdBQUdBLG9CQUFvQjtRQUN2QixHQUFHbEIsR0FBRztJQUNSO0FBQ0Y7QUFFQTs7O0FBR0EsR0FFb0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uYXNhLXNwYWNlLWJpb2xvZ3ktZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL21hdGNoLXNvcnRlci9kaXN0L21hdGNoLXNvcnRlci5lc20uanM/ODMyMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcmVtb3ZlQWNjZW50cyBmcm9tICdyZW1vdmUtYWNjZW50cyc7XHJcblxyXG4vKipcclxuICogQG5hbWUgbWF0Y2gtc29ydGVyXHJcbiAqIEBsaWNlbnNlIE1JVCBsaWNlbnNlLlxyXG4gKiBAY29weXJpZ2h0IChjKSAyMDIwIEtlbnQgQy4gRG9kZHNcclxuICogQGF1dGhvciBLZW50IEMuIERvZGRzIDxtZUBrZW50Y2RvZGRzLmNvbT4gKGh0dHBzOi8va2VudGNkb2Rkcy5jb20pXHJcbiAqL1xyXG5jb25zdCByYW5raW5ncyA9IHtcclxuICBDQVNFX1NFTlNJVElWRV9FUVVBTDogNyxcclxuICBFUVVBTDogNixcclxuICBTVEFSVFNfV0lUSDogNSxcclxuICBXT1JEX1NUQVJUU19XSVRIOiA0LFxyXG4gIENPTlRBSU5TOiAzLFxyXG4gIEFDUk9OWU06IDIsXHJcbiAgTUFUQ0hFUzogMSxcclxuICBOT19NQVRDSDogMFxyXG59O1xyXG5jb25zdCBkZWZhdWx0QmFzZVNvcnRGbiA9IChhLCBiKSA9PiBTdHJpbmcoYS5yYW5rZWRWYWx1ZSkubG9jYWxlQ29tcGFyZShTdHJpbmcoYi5yYW5rZWRWYWx1ZSkpO1xyXG5cclxuLyoqXHJcbiAqIFRha2VzIGFuIGFycmF5IG9mIGl0ZW1zIGFuZCBhIHZhbHVlIGFuZCByZXR1cm5zIGEgbmV3IGFycmF5IHdpdGggdGhlIGl0ZW1zIHRoYXQgbWF0Y2ggdGhlIGdpdmVuIHZhbHVlXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGl0ZW1zIC0gdGhlIGl0ZW1zIHRvIHNvcnRcclxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIC0gdGhlIHZhbHVlIHRvIHVzZSBmb3IgcmFua2luZ1xyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFNvbWUgb3B0aW9ucyB0byBjb25maWd1cmUgdGhlIHNvcnRlclxyXG4gKiBAcmV0dXJuIHtBcnJheX0gLSB0aGUgbmV3IHNvcnRlZCBhcnJheVxyXG4gKi9cclxuZnVuY3Rpb24gbWF0Y2hTb3J0ZXIoaXRlbXMsIHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xyXG4gICAgb3B0aW9ucyA9IHt9O1xyXG4gIH1cclxuICBjb25zdCB7XHJcbiAgICBrZXlzLFxyXG4gICAgdGhyZXNob2xkID0gcmFua2luZ3MuTUFUQ0hFUyxcclxuICAgIGJhc2VTb3J0ID0gZGVmYXVsdEJhc2VTb3J0Rm4sXHJcbiAgICBzb3J0ZXIgPSBtYXRjaGVkSXRlbXMgPT4gbWF0Y2hlZEl0ZW1zLnNvcnQoKGEsIGIpID0+IHNvcnRSYW5rZWRWYWx1ZXMoYSwgYiwgYmFzZVNvcnQpKVxyXG4gIH0gPSBvcHRpb25zO1xyXG4gIGNvbnN0IG1hdGNoZWRJdGVtcyA9IGl0ZW1zLnJlZHVjZShyZWR1Y2VJdGVtc1RvUmFua2VkLCBbXSk7XHJcbiAgcmV0dXJuIHNvcnRlcihtYXRjaGVkSXRlbXMpLm1hcChfcmVmID0+IHtcclxuICAgIGxldCB7XHJcbiAgICAgIGl0ZW1cclxuICAgIH0gPSBfcmVmO1xyXG4gICAgcmV0dXJuIGl0ZW07XHJcbiAgfSk7XHJcbiAgZnVuY3Rpb24gcmVkdWNlSXRlbXNUb1JhbmtlZChtYXRjaGVzLCBpdGVtLCBpbmRleCkge1xyXG4gICAgY29uc3QgcmFua2luZ0luZm8gPSBnZXRIaWdoZXN0UmFua2luZyhpdGVtLCBrZXlzLCB2YWx1ZSwgb3B0aW9ucyk7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgIHJhbmssXHJcbiAgICAgIGtleVRocmVzaG9sZCA9IHRocmVzaG9sZFxyXG4gICAgfSA9IHJhbmtpbmdJbmZvO1xyXG4gICAgaWYgKHJhbmsgPj0ga2V5VGhyZXNob2xkKSB7XHJcbiAgICAgIG1hdGNoZXMucHVzaCh7XHJcbiAgICAgICAgLi4ucmFua2luZ0luZm8sXHJcbiAgICAgICAgaXRlbSxcclxuICAgICAgICBpbmRleFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBtYXRjaGVzO1xyXG4gIH1cclxufVxyXG5tYXRjaFNvcnRlci5yYW5raW5ncyA9IHJhbmtpbmdzO1xyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIGhpZ2hlc3QgcmFua2luZyBmb3IgdmFsdWUgZm9yIHRoZSBnaXZlbiBpdGVtIGJhc2VkIG9uIGl0cyB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBrZXlzXHJcbiAqIEBwYXJhbSB7Kn0gaXRlbSAtIHRoZSBpdGVtIHRvIHJhbmtcclxuICogQHBhcmFtIHtBcnJheX0ga2V5cyAtIHRoZSBrZXlzIHRvIGdldCB2YWx1ZXMgZnJvbSB0aGUgaXRlbSBmb3IgdGhlIHJhbmtpbmdcclxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIC0gdGhlIHZhbHVlIHRvIHJhbmsgYWdhaW5zdFxyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgdG8gY29udHJvbCB0aGUgcmFua2luZ1xyXG4gKiBAcmV0dXJuIHt7cmFuazogTnVtYmVyLCBrZXlJbmRleDogTnVtYmVyLCBrZXlUaHJlc2hvbGQ6IE51bWJlcn19IC0gdGhlIGhpZ2hlc3QgcmFua2luZ1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0SGlnaGVzdFJhbmtpbmcoaXRlbSwga2V5cywgdmFsdWUsIG9wdGlvbnMpIHtcclxuICBpZiAoIWtleXMpIHtcclxuICAgIC8vIGlmIGtleXMgaXMgbm90IHNwZWNpZmllZCwgdGhlbiB3ZSBhc3N1bWUgdGhlIGl0ZW0gZ2l2ZW4gaXMgcmVhZHkgdG8gYmUgbWF0Y2hlZFxyXG4gICAgY29uc3Qgc3RyaW5nSXRlbSA9IGl0ZW07XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAvLyBlbmRzIHVwIGJlaW5nIGR1cGxpY2F0ZSBvZiAnaXRlbScgaW4gbWF0Y2hlcyBidXQgY29uc2lzdGVudFxyXG4gICAgICByYW5rZWRWYWx1ZTogc3RyaW5nSXRlbSxcclxuICAgICAgcmFuazogZ2V0TWF0Y2hSYW5raW5nKHN0cmluZ0l0ZW0sIHZhbHVlLCBvcHRpb25zKSxcclxuICAgICAga2V5SW5kZXg6IC0xLFxyXG4gICAgICBrZXlUaHJlc2hvbGQ6IG9wdGlvbnMudGhyZXNob2xkXHJcbiAgICB9O1xyXG4gIH1cclxuICBjb25zdCB2YWx1ZXNUb1JhbmsgPSBnZXRBbGxWYWx1ZXNUb1JhbmsoaXRlbSwga2V5cyk7XHJcbiAgcmV0dXJuIHZhbHVlc1RvUmFuay5yZWR1Y2UoKF9yZWYyLCBfcmVmMywgaSkgPT4ge1xyXG4gICAgbGV0IHtcclxuICAgICAgcmFuayxcclxuICAgICAgcmFua2VkVmFsdWUsXHJcbiAgICAgIGtleUluZGV4LFxyXG4gICAgICBrZXlUaHJlc2hvbGRcclxuICAgIH0gPSBfcmVmMjtcclxuICAgIGxldCB7XHJcbiAgICAgIGl0ZW1WYWx1ZSxcclxuICAgICAgYXR0cmlidXRlc1xyXG4gICAgfSA9IF9yZWYzO1xyXG4gICAgbGV0IG5ld1JhbmsgPSBnZXRNYXRjaFJhbmtpbmcoaXRlbVZhbHVlLCB2YWx1ZSwgb3B0aW9ucyk7XHJcbiAgICBsZXQgbmV3UmFua2VkVmFsdWUgPSByYW5rZWRWYWx1ZTtcclxuICAgIGNvbnN0IHtcclxuICAgICAgbWluUmFua2luZyxcclxuICAgICAgbWF4UmFua2luZyxcclxuICAgICAgdGhyZXNob2xkXHJcbiAgICB9ID0gYXR0cmlidXRlcztcclxuICAgIGlmIChuZXdSYW5rIDwgbWluUmFua2luZyAmJiBuZXdSYW5rID49IHJhbmtpbmdzLk1BVENIRVMpIHtcclxuICAgICAgbmV3UmFuayA9IG1pblJhbmtpbmc7XHJcbiAgICB9IGVsc2UgaWYgKG5ld1JhbmsgPiBtYXhSYW5raW5nKSB7XHJcbiAgICAgIG5ld1JhbmsgPSBtYXhSYW5raW5nO1xyXG4gICAgfVxyXG4gICAgaWYgKG5ld1JhbmsgPiByYW5rKSB7XHJcbiAgICAgIHJhbmsgPSBuZXdSYW5rO1xyXG4gICAgICBrZXlJbmRleCA9IGk7XHJcbiAgICAgIGtleVRocmVzaG9sZCA9IHRocmVzaG9sZDtcclxuICAgICAgbmV3UmFua2VkVmFsdWUgPSBpdGVtVmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICByYW5rZWRWYWx1ZTogbmV3UmFua2VkVmFsdWUsXHJcbiAgICAgIHJhbmssXHJcbiAgICAgIGtleUluZGV4LFxyXG4gICAgICBrZXlUaHJlc2hvbGRcclxuICAgIH07XHJcbiAgfSwge1xyXG4gICAgcmFua2VkVmFsdWU6IGl0ZW0sXHJcbiAgICByYW5rOiByYW5raW5ncy5OT19NQVRDSCxcclxuICAgIGtleUluZGV4OiAtMSxcclxuICAgIGtleVRocmVzaG9sZDogb3B0aW9ucy50aHJlc2hvbGRcclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdpdmVzIGEgcmFua2luZ3Mgc2NvcmUgYmFzZWQgb24gaG93IHdlbGwgdGhlIHR3byBzdHJpbmdzIG1hdGNoLlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdGVzdFN0cmluZyAtIHRoZSBzdHJpbmcgdG8gdGVzdCBhZ2FpbnN0XHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmdUb1JhbmsgLSB0aGUgc3RyaW5nIHRvIHJhbmtcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIGZvciB0aGUgbWF0Y2ggKGxpa2Uga2VlcERpYWNyaXRpY3MgZm9yIGNvbXBhcmlzb24pXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSByYW5raW5nIGZvciBob3cgd2VsbCBzdHJpbmdUb1JhbmsgbWF0Y2hlcyB0ZXN0U3RyaW5nXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRNYXRjaFJhbmtpbmcodGVzdFN0cmluZywgc3RyaW5nVG9SYW5rLCBvcHRpb25zKSB7XHJcbiAgdGVzdFN0cmluZyA9IHByZXBhcmVWYWx1ZUZvckNvbXBhcmlzb24odGVzdFN0cmluZywgb3B0aW9ucyk7XHJcbiAgc3RyaW5nVG9SYW5rID0gcHJlcGFyZVZhbHVlRm9yQ29tcGFyaXNvbihzdHJpbmdUb1JhbmssIG9wdGlvbnMpO1xyXG5cclxuICAvLyB0b28gbG9uZ1xyXG4gIGlmIChzdHJpbmdUb1JhbmsubGVuZ3RoID4gdGVzdFN0cmluZy5sZW5ndGgpIHtcclxuICAgIHJldHVybiByYW5raW5ncy5OT19NQVRDSDtcclxuICB9XHJcblxyXG4gIC8vIGNhc2Ugc2Vuc2l0aXZlIGVxdWFsc1xyXG4gIGlmICh0ZXN0U3RyaW5nID09PSBzdHJpbmdUb1JhbmspIHtcclxuICAgIHJldHVybiByYW5raW5ncy5DQVNFX1NFTlNJVElWRV9FUVVBTDtcclxuICB9XHJcblxyXG4gIC8vIExvd2VyIGNhc2luZyBiZWZvcmUgZnVydGhlciBjb21wYXJpc29uXHJcbiAgdGVzdFN0cmluZyA9IHRlc3RTdHJpbmcudG9Mb3dlckNhc2UoKTtcclxuICBzdHJpbmdUb1JhbmsgPSBzdHJpbmdUb1JhbmsudG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgLy8gY2FzZSBpbnNlbnNpdGl2ZSBlcXVhbHNcclxuICBpZiAodGVzdFN0cmluZyA9PT0gc3RyaW5nVG9SYW5rKSB7XHJcbiAgICByZXR1cm4gcmFua2luZ3MuRVFVQUw7XHJcbiAgfVxyXG5cclxuICAvLyBzdGFydHMgd2l0aFxyXG4gIGlmICh0ZXN0U3RyaW5nLnN0YXJ0c1dpdGgoc3RyaW5nVG9SYW5rKSkge1xyXG4gICAgcmV0dXJuIHJhbmtpbmdzLlNUQVJUU19XSVRIO1xyXG4gIH1cclxuXHJcbiAgLy8gd29yZCBzdGFydHMgd2l0aFxyXG4gIGlmICh0ZXN0U3RyaW5nLmluY2x1ZGVzKGAgJHtzdHJpbmdUb1Jhbmt9YCkpIHtcclxuICAgIHJldHVybiByYW5raW5ncy5XT1JEX1NUQVJUU19XSVRIO1xyXG4gIH1cclxuXHJcbiAgLy8gY29udGFpbnNcclxuICBpZiAodGVzdFN0cmluZy5pbmNsdWRlcyhzdHJpbmdUb1JhbmspKSB7XHJcbiAgICByZXR1cm4gcmFua2luZ3MuQ09OVEFJTlM7XHJcbiAgfSBlbHNlIGlmIChzdHJpbmdUb1JhbmsubGVuZ3RoID09PSAxKSB7XHJcbiAgICAvLyBJZiB0aGUgb25seSBjaGFyYWN0ZXIgaW4gdGhlIGdpdmVuIHN0cmluZ1RvUmFua1xyXG4gICAgLy8gICBpc24ndCBldmVuIGNvbnRhaW5lZCBpbiB0aGUgdGVzdFN0cmluZywgdGhlblxyXG4gICAgLy8gICBpdCdzIGRlZmluaXRlbHkgbm90IGEgbWF0Y2guXHJcbiAgICByZXR1cm4gcmFua2luZ3MuTk9fTUFUQ0g7XHJcbiAgfVxyXG5cclxuICAvLyBhY3JvbnltXHJcbiAgaWYgKGdldEFjcm9ueW0odGVzdFN0cmluZykuaW5jbHVkZXMoc3RyaW5nVG9SYW5rKSkge1xyXG4gICAgcmV0dXJuIHJhbmtpbmdzLkFDUk9OWU07XHJcbiAgfVxyXG5cclxuICAvLyB3aWxsIHJldHVybiBhIG51bWJlciBiZXR3ZWVuIHJhbmtpbmdzLk1BVENIRVMgYW5kXHJcbiAgLy8gcmFua2luZ3MuTUFUQ0hFUyArIDEgZGVwZW5kaW5nICBvbiBob3cgY2xvc2Ugb2YgYSBtYXRjaCBpdCBpcy5cclxuICByZXR1cm4gZ2V0Q2xvc2VuZXNzUmFua2luZyh0ZXN0U3RyaW5nLCBzdHJpbmdUb1JhbmspO1xyXG59XHJcblxyXG4vKipcclxuICogR2VuZXJhdGVzIGFuIGFjcm9ueW0gZm9yIGEgc3RyaW5nLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIHRoZSBzdHJpbmcgZm9yIHdoaWNoIHRvIHByb2R1Y2UgdGhlIGFjcm9ueW1cclxuICogQHJldHVybnMge1N0cmluZ30gdGhlIGFjcm9ueW1cclxuICovXHJcbmZ1bmN0aW9uIGdldEFjcm9ueW0oc3RyaW5nKSB7XHJcbiAgbGV0IGFjcm9ueW0gPSAnJztcclxuICBjb25zdCB3b3Jkc0luU3RyaW5nID0gc3RyaW5nLnNwbGl0KCcgJyk7XHJcbiAgd29yZHNJblN0cmluZy5mb3JFYWNoKHdvcmRJblN0cmluZyA9PiB7XHJcbiAgICBjb25zdCBzcGxpdEJ5SHlwaGVuV29yZHMgPSB3b3JkSW5TdHJpbmcuc3BsaXQoJy0nKTtcclxuICAgIHNwbGl0QnlIeXBoZW5Xb3Jkcy5mb3JFYWNoKHNwbGl0QnlIeXBoZW5Xb3JkID0+IHtcclxuICAgICAgYWNyb255bSArPSBzcGxpdEJ5SHlwaGVuV29yZC5zdWJzdHIoMCwgMSk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuICByZXR1cm4gYWNyb255bTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBzY29yZSBiYXNlZCBvbiBob3cgc3ByZWFkIGFwYXJ0IHRoZVxyXG4gKiBjaGFyYWN0ZXJzIGZyb20gdGhlIHN0cmluZ1RvUmFuayBhcmUgd2l0aGluIHRoZSB0ZXN0U3RyaW5nLlxyXG4gKiBBIG51bWJlciBjbG9zZSB0byByYW5raW5ncy5NQVRDSEVTIHJlcHJlc2VudHMgYSBsb29zZSBtYXRjaC4gQSBudW1iZXIgY2xvc2VcclxuICogdG8gcmFua2luZ3MuTUFUQ0hFUyArIDEgcmVwcmVzZW50cyBhIHRpZ2h0ZXIgbWF0Y2guXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXN0U3RyaW5nIC0gdGhlIHN0cmluZyB0byB0ZXN0IGFnYWluc3RcclxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1RvUmFuayAtIHRoZSBzdHJpbmcgdG8gcmFua1xyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgbnVtYmVyIGJldHdlZW4gcmFua2luZ3MuTUFUQ0hFUyBhbmRcclxuICogcmFua2luZ3MuTUFUQ0hFUyArIDEgZm9yIGhvdyB3ZWxsIHN0cmluZ1RvUmFuayBtYXRjaGVzIHRlc3RTdHJpbmdcclxuICovXHJcbmZ1bmN0aW9uIGdldENsb3NlbmVzc1JhbmtpbmcodGVzdFN0cmluZywgc3RyaW5nVG9SYW5rKSB7XHJcbiAgbGV0IG1hdGNoaW5nSW5PcmRlckNoYXJDb3VudCA9IDA7XHJcbiAgbGV0IGNoYXJOdW1iZXIgPSAwO1xyXG4gIGZ1bmN0aW9uIGZpbmRNYXRjaGluZ0NoYXJhY3RlcihtYXRjaENoYXIsIHN0cmluZywgaW5kZXgpIHtcclxuICAgIGZvciAobGV0IGogPSBpbmRleCwgSiA9IHN0cmluZy5sZW5ndGg7IGogPCBKOyBqKyspIHtcclxuICAgICAgY29uc3Qgc3RyaW5nQ2hhciA9IHN0cmluZ1tqXTtcclxuICAgICAgaWYgKHN0cmluZ0NoYXIgPT09IG1hdGNoQ2hhcikge1xyXG4gICAgICAgIG1hdGNoaW5nSW5PcmRlckNoYXJDb3VudCArPSAxO1xyXG4gICAgICAgIHJldHVybiBqICsgMTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIC0xO1xyXG4gIH1cclxuICBmdW5jdGlvbiBnZXRSYW5raW5nKHNwcmVhZCkge1xyXG4gICAgY29uc3Qgc3ByZWFkUGVyY2VudGFnZSA9IDEgLyBzcHJlYWQ7XHJcbiAgICBjb25zdCBpbk9yZGVyUGVyY2VudGFnZSA9IG1hdGNoaW5nSW5PcmRlckNoYXJDb3VudCAvIHN0cmluZ1RvUmFuay5sZW5ndGg7XHJcbiAgICBjb25zdCByYW5raW5nID0gcmFua2luZ3MuTUFUQ0hFUyArIGluT3JkZXJQZXJjZW50YWdlICogc3ByZWFkUGVyY2VudGFnZTtcclxuICAgIHJldHVybiByYW5raW5nO1xyXG4gIH1cclxuICBjb25zdCBmaXJzdEluZGV4ID0gZmluZE1hdGNoaW5nQ2hhcmFjdGVyKHN0cmluZ1RvUmFua1swXSwgdGVzdFN0cmluZywgMCk7XHJcbiAgaWYgKGZpcnN0SW5kZXggPCAwKSB7XHJcbiAgICByZXR1cm4gcmFua2luZ3MuTk9fTUFUQ0g7XHJcbiAgfVxyXG4gIGNoYXJOdW1iZXIgPSBmaXJzdEluZGV4O1xyXG4gIGZvciAobGV0IGkgPSAxLCBJID0gc3RyaW5nVG9SYW5rLmxlbmd0aDsgaSA8IEk7IGkrKykge1xyXG4gICAgY29uc3QgbWF0Y2hDaGFyID0gc3RyaW5nVG9SYW5rW2ldO1xyXG4gICAgY2hhck51bWJlciA9IGZpbmRNYXRjaGluZ0NoYXJhY3RlcihtYXRjaENoYXIsIHRlc3RTdHJpbmcsIGNoYXJOdW1iZXIpO1xyXG4gICAgY29uc3QgZm91bmQgPSBjaGFyTnVtYmVyID4gLTE7XHJcbiAgICBpZiAoIWZvdW5kKSB7XHJcbiAgICAgIHJldHVybiByYW5raW5ncy5OT19NQVRDSDtcclxuICAgIH1cclxuICB9XHJcbiAgY29uc3Qgc3ByZWFkID0gY2hhck51bWJlciAtIGZpcnN0SW5kZXg7XHJcbiAgcmV0dXJuIGdldFJhbmtpbmcoc3ByZWFkKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNvcnRzIGl0ZW1zIHRoYXQgaGF2ZSBhIHJhbmssIGluZGV4LCBhbmQga2V5SW5kZXhcclxuICogQHBhcmFtIHtPYmplY3R9IGEgLSB0aGUgZmlyc3QgaXRlbSB0byBzb3J0XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBiIC0gdGhlIHNlY29uZCBpdGVtIHRvIHNvcnRcclxuICogQHJldHVybiB7TnVtYmVyfSAtMSBpZiBhIHNob3VsZCBjb21lIGZpcnN0LCAxIGlmIGIgc2hvdWxkIGNvbWUgZmlyc3QsIDAgaWYgZXF1YWxcclxuICovXHJcbmZ1bmN0aW9uIHNvcnRSYW5rZWRWYWx1ZXMoYSwgYiwgYmFzZVNvcnQpIHtcclxuICBjb25zdCBhRmlyc3QgPSAtMTtcclxuICBjb25zdCBiRmlyc3QgPSAxO1xyXG4gIGNvbnN0IHtcclxuICAgIHJhbms6IGFSYW5rLFxyXG4gICAga2V5SW5kZXg6IGFLZXlJbmRleFxyXG4gIH0gPSBhO1xyXG4gIGNvbnN0IHtcclxuICAgIHJhbms6IGJSYW5rLFxyXG4gICAga2V5SW5kZXg6IGJLZXlJbmRleFxyXG4gIH0gPSBiO1xyXG4gIGNvbnN0IHNhbWUgPSBhUmFuayA9PT0gYlJhbms7XHJcbiAgaWYgKHNhbWUpIHtcclxuICAgIGlmIChhS2V5SW5kZXggPT09IGJLZXlJbmRleCkge1xyXG4gICAgICAvLyB1c2UgdGhlIGJhc2Ugc29ydCBmdW5jdGlvbiBhcyBhIHRpZS1icmVha2VyXHJcbiAgICAgIHJldHVybiBiYXNlU29ydChhLCBiKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBhS2V5SW5kZXggPCBiS2V5SW5kZXggPyBhRmlyc3QgOiBiRmlyc3Q7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBhUmFuayA+IGJSYW5rID8gYUZpcnN0IDogYkZpcnN0O1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFByZXBhcmVzIHZhbHVlIGZvciBjb21wYXJpc29uIGJ5IHN0cmluZ2lmeWluZyBpdCwgcmVtb3ZpbmcgZGlhY3JpdGljcyAoaWYgc3BlY2lmaWVkKVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgLSB0aGUgdmFsdWUgdG8gY2xlYW5cclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSB7a2VlcERpYWNyaXRpY3M6IHdoZXRoZXIgdG8gcmVtb3ZlIGRpYWNyaXRpY3N9XHJcbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIHByZXBhcmVkIHZhbHVlXHJcbiAqL1xyXG5mdW5jdGlvbiBwcmVwYXJlVmFsdWVGb3JDb21wYXJpc29uKHZhbHVlLCBfcmVmNCkge1xyXG4gIGxldCB7XHJcbiAgICBrZWVwRGlhY3JpdGljc1xyXG4gIH0gPSBfcmVmNDtcclxuICAvLyB2YWx1ZSBtaWdodCBub3QgYWN0dWFsbHkgYmUgYSBzdHJpbmcgYXQgdGhpcyBwb2ludCAod2UgZG9uJ3QgZ2V0IHRvIGNob29zZSlcclxuICAvLyBzbyBwYXJ0IG9mIHByZXBhcmluZyB0aGUgdmFsdWUgZm9yIGNvbXBhcmlzb24gaXMgZW5zdXJlIHRoYXQgaXQgaXMgYSBzdHJpbmdcclxuICB2YWx1ZSA9IGAke3ZhbHVlfWA7IC8vIHRvU3RyaW5nXHJcbiAgaWYgKCFrZWVwRGlhY3JpdGljcykge1xyXG4gICAgdmFsdWUgPSByZW1vdmVBY2NlbnRzKHZhbHVlKTtcclxuICB9XHJcbiAgcmV0dXJuIHZhbHVlO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0cyB2YWx1ZSBmb3Iga2V5IGluIGl0ZW0gYXQgYXJiaXRyYXJpbHkgbmVzdGVkIGtleXBhdGhcclxuICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gLSB0aGUgaXRlbVxyXG4gKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0ga2V5IC0gdGhlIHBvdGVudGlhbGx5IG5lc3RlZCBrZXlwYXRoIG9yIHByb3BlcnR5IGNhbGxiYWNrXHJcbiAqIEByZXR1cm4ge0FycmF5fSAtIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHZhbHVlKHMpIGF0IHRoZSBuZXN0ZWQga2V5cGF0aFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0SXRlbVZhbHVlcyhpdGVtLCBrZXkpIHtcclxuICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcclxuICAgIGtleSA9IGtleS5rZXk7XHJcbiAgfVxyXG4gIGxldCB2YWx1ZTtcclxuICBpZiAodHlwZW9mIGtleSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgdmFsdWUgPSBrZXkoaXRlbSk7XHJcbiAgfSBlbHNlIGlmIChpdGVtID09IG51bGwpIHtcclxuICAgIHZhbHVlID0gbnVsbDtcclxuICB9IGVsc2UgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGl0ZW0sIGtleSkpIHtcclxuICAgIHZhbHVlID0gaXRlbVtrZXldO1xyXG4gIH0gZWxzZSBpZiAoa2V5LmluY2x1ZGVzKCcuJykpIHtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWNhbGxcclxuICAgIHJldHVybiBnZXROZXN0ZWRWYWx1ZXMoa2V5LCBpdGVtKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdmFsdWUgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLy8gYmVjYXVzZSBgdmFsdWVgIGNhbiBhbHNvIGJlIHVuZGVmaW5lZFxyXG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG4gIH1cclxuICByZXR1cm4gW1N0cmluZyh2YWx1ZSldO1xyXG59XHJcblxyXG4vKipcclxuICogR2l2ZW4gcGF0aDogXCJmb28uYmFyLmJhelwiXHJcbiAqIEFuZCBpdGVtOiB7Zm9vOiB7YmFyOiB7YmF6OiAnYnV6eid9fX1cclxuICogICAtPiAnYnV6eidcclxuICogQHBhcmFtIHBhdGggYSBkb3Qtc2VwYXJhdGVkIHNldCBvZiBrZXlzXHJcbiAqIEBwYXJhbSBpdGVtIHRoZSBpdGVtIHRvIGdldCB0aGUgdmFsdWUgZnJvbVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0TmVzdGVkVmFsdWVzKHBhdGgsIGl0ZW0pIHtcclxuICBjb25zdCBrZXlzID0gcGF0aC5zcGxpdCgnLicpO1xyXG4gIGxldCB2YWx1ZXMgPSBbaXRlbV07XHJcbiAgZm9yIChsZXQgaSA9IDAsIEkgPSBrZXlzLmxlbmd0aDsgaSA8IEk7IGkrKykge1xyXG4gICAgY29uc3QgbmVzdGVkS2V5ID0ga2V5c1tpXTtcclxuICAgIGxldCBuZXN0ZWRWYWx1ZXMgPSBbXTtcclxuICAgIGZvciAobGV0IGogPSAwLCBKID0gdmFsdWVzLmxlbmd0aDsgaiA8IEo7IGorKykge1xyXG4gICAgICBjb25zdCBuZXN0ZWRJdGVtID0gdmFsdWVzW2pdO1xyXG4gICAgICBpZiAobmVzdGVkSXRlbSA9PSBudWxsKSBjb250aW51ZTtcclxuICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5lc3RlZEl0ZW0sIG5lc3RlZEtleSkpIHtcclxuICAgICAgICBjb25zdCBuZXN0ZWRWYWx1ZSA9IG5lc3RlZEl0ZW1bbmVzdGVkS2V5XTtcclxuICAgICAgICBpZiAobmVzdGVkVmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgbmVzdGVkVmFsdWVzLnB1c2gobmVzdGVkVmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChuZXN0ZWRLZXkgPT09ICcqJykge1xyXG4gICAgICAgIC8vIGVuc3VyZSB0aGF0IHZhbHVlcyBpcyBhbiBhcnJheVxyXG4gICAgICAgIG5lc3RlZFZhbHVlcyA9IG5lc3RlZFZhbHVlcy5jb25jYXQobmVzdGVkSXRlbSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHZhbHVlcyA9IG5lc3RlZFZhbHVlcztcclxuICB9XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzWzBdKSkge1xyXG4gICAgLy8ga2VlcCBhbGxvd2luZyB0aGUgaW1wbGljaXQgd2lsZGNhcmQgZm9yIGFuIGFycmF5IG9mIHN0cmluZ3MgYXQgdGhlIGVuZCBvZlxyXG4gICAgLy8gdGhlIHBhdGg7IGRvbid0IHVzZSBgLmZsYXQoKWAgYmVjYXVzZSB0aGF0J3Mgbm90IGF2YWlsYWJsZSBpbiBub2RlLmpzIHYxMFxyXG4gICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICByZXR1cm4gcmVzdWx0LmNvbmNhdCguLi52YWx1ZXMpO1xyXG4gIH1cclxuICAvLyBCYXNlZCBvbiBvdXIgbG9naWMgaXQgc2hvdWxkIGJlIGFuIGFycmF5IG9mIHN0cmluZ3MgYnkgbm93Li4uXHJcbiAgLy8gYXNzdW1pbmcgdGhlIHVzZXIncyBwYXRoIHRlcm1pbmF0ZWQgaW4gc3RyaW5nc1xyXG4gIHJldHVybiB2YWx1ZXM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXRzIGFsbCB0aGUgdmFsdWVzIGZvciB0aGUgZ2l2ZW4ga2V5cyBpbiB0aGUgZ2l2ZW4gaXRlbSBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aG9zZSB2YWx1ZXNcclxuICogQHBhcmFtIGl0ZW0gLSB0aGUgaXRlbSBmcm9tIHdoaWNoIHRoZSB2YWx1ZXMgd2lsbCBiZSByZXRyaWV2ZWRcclxuICogQHBhcmFtIGtleXMgLSB0aGUga2V5cyB0byB1c2UgdG8gcmV0cmlldmUgdGhlIHZhbHVlc1xyXG4gKiBAcmV0dXJuIG9iamVjdHMgd2l0aCB7aXRlbVZhbHVlLCBhdHRyaWJ1dGVzfVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0QWxsVmFsdWVzVG9SYW5rKGl0ZW0sIGtleXMpIHtcclxuICBjb25zdCBhbGxWYWx1ZXMgPSBbXTtcclxuICBmb3IgKGxldCBqID0gMCwgSiA9IGtleXMubGVuZ3RoOyBqIDwgSjsgaisrKSB7XHJcbiAgICBjb25zdCBrZXkgPSBrZXlzW2pdO1xyXG4gICAgY29uc3QgYXR0cmlidXRlcyA9IGdldEtleUF0dHJpYnV0ZXMoa2V5KTtcclxuICAgIGNvbnN0IGl0ZW1WYWx1ZXMgPSBnZXRJdGVtVmFsdWVzKGl0ZW0sIGtleSk7XHJcbiAgICBmb3IgKGxldCBpID0gMCwgSSA9IGl0ZW1WYWx1ZXMubGVuZ3RoOyBpIDwgSTsgaSsrKSB7XHJcbiAgICAgIGFsbFZhbHVlcy5wdXNoKHtcclxuICAgICAgICBpdGVtVmFsdWU6IGl0ZW1WYWx1ZXNbaV0sXHJcbiAgICAgICAgYXR0cmlidXRlc1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGFsbFZhbHVlcztcclxufVxyXG5jb25zdCBkZWZhdWx0S2V5QXR0cmlidXRlcyA9IHtcclxuICBtYXhSYW5raW5nOiBJbmZpbml0eSxcclxuICBtaW5SYW5raW5nOiAtSW5maW5pdHlcclxufTtcclxuLyoqXHJcbiAqIEdldHMgYWxsIHRoZSBhdHRyaWJ1dGVzIGZvciB0aGUgZ2l2ZW4ga2V5XHJcbiAqIEBwYXJhbSBrZXkgLSB0aGUga2V5IGZyb20gd2hpY2ggdGhlIGF0dHJpYnV0ZXMgd2lsbCBiZSByZXRyaWV2ZWRcclxuICogQHJldHVybiBvYmplY3QgY29udGFpbmluZyB0aGUga2V5J3MgYXR0cmlidXRlc1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0S2V5QXR0cmlidXRlcyhrZXkpIHtcclxuICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVybiBkZWZhdWx0S2V5QXR0cmlidXRlcztcclxuICB9XHJcbiAgcmV0dXJuIHtcclxuICAgIC4uLmRlZmF1bHRLZXlBdHRyaWJ1dGVzLFxyXG4gICAgLi4ua2V5XHJcbiAgfTtcclxufVxyXG5cclxuLypcclxuZXNsaW50XHJcbiAgbm8tY29udGludWU6IFwib2ZmXCIsXHJcbiovXHJcblxyXG5leHBvcnQgeyBkZWZhdWx0QmFzZVNvcnRGbiwgbWF0Y2hTb3J0ZXIsIHJhbmtpbmdzIH07XHJcbiJdLCJuYW1lcyI6WyJyZW1vdmVBY2NlbnRzIiwicmFua2luZ3MiLCJDQVNFX1NFTlNJVElWRV9FUVVBTCIsIkVRVUFMIiwiU1RBUlRTX1dJVEgiLCJXT1JEX1NUQVJUU19XSVRIIiwiQ09OVEFJTlMiLCJBQ1JPTllNIiwiTUFUQ0hFUyIsIk5PX01BVENIIiwiZGVmYXVsdEJhc2VTb3J0Rm4iLCJhIiwiYiIsIlN0cmluZyIsInJhbmtlZFZhbHVlIiwibG9jYWxlQ29tcGFyZSIsIm1hdGNoU29ydGVyIiwiaXRlbXMiLCJ2YWx1ZSIsIm9wdGlvbnMiLCJrZXlzIiwidGhyZXNob2xkIiwiYmFzZVNvcnQiLCJzb3J0ZXIiLCJtYXRjaGVkSXRlbXMiLCJzb3J0Iiwic29ydFJhbmtlZFZhbHVlcyIsInJlZHVjZSIsInJlZHVjZUl0ZW1zVG9SYW5rZWQiLCJtYXAiLCJfcmVmIiwiaXRlbSIsIm1hdGNoZXMiLCJpbmRleCIsInJhbmtpbmdJbmZvIiwiZ2V0SGlnaGVzdFJhbmtpbmciLCJyYW5rIiwia2V5VGhyZXNob2xkIiwicHVzaCIsInN0cmluZ0l0ZW0iLCJnZXRNYXRjaFJhbmtpbmciLCJrZXlJbmRleCIsInZhbHVlc1RvUmFuayIsImdldEFsbFZhbHVlc1RvUmFuayIsIl9yZWYyIiwiX3JlZjMiLCJpIiwiaXRlbVZhbHVlIiwiYXR0cmlidXRlcyIsIm5ld1JhbmsiLCJuZXdSYW5rZWRWYWx1ZSIsIm1pblJhbmtpbmciLCJtYXhSYW5raW5nIiwidGVzdFN0cmluZyIsInN0cmluZ1RvUmFuayIsInByZXBhcmVWYWx1ZUZvckNvbXBhcmlzb24iLCJsZW5ndGgiLCJ0b0xvd2VyQ2FzZSIsInN0YXJ0c1dpdGgiLCJpbmNsdWRlcyIsImdldEFjcm9ueW0iLCJnZXRDbG9zZW5lc3NSYW5raW5nIiwic3RyaW5nIiwiYWNyb255bSIsIndvcmRzSW5TdHJpbmciLCJzcGxpdCIsImZvckVhY2giLCJ3b3JkSW5TdHJpbmciLCJzcGxpdEJ5SHlwaGVuV29yZHMiLCJzcGxpdEJ5SHlwaGVuV29yZCIsInN1YnN0ciIsIm1hdGNoaW5nSW5PcmRlckNoYXJDb3VudCIsImNoYXJOdW1iZXIiLCJmaW5kTWF0Y2hpbmdDaGFyYWN0ZXIiLCJtYXRjaENoYXIiLCJqIiwiSiIsInN0cmluZ0NoYXIiLCJnZXRSYW5raW5nIiwic3ByZWFkIiwic3ByZWFkUGVyY2VudGFnZSIsImluT3JkZXJQZXJjZW50YWdlIiwicmFua2luZyIsImZpcnN0SW5kZXgiLCJJIiwiZm91bmQiLCJhRmlyc3QiLCJiRmlyc3QiLCJhUmFuayIsImFLZXlJbmRleCIsImJSYW5rIiwiYktleUluZGV4Iiwic2FtZSIsIl9yZWY0Iiwia2VlcERpYWNyaXRpY3MiLCJnZXRJdGVtVmFsdWVzIiwia2V5IiwiT2JqZWN0IiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiZ2V0TmVzdGVkVmFsdWVzIiwiQXJyYXkiLCJpc0FycmF5IiwicGF0aCIsInZhbHVlcyIsIm5lc3RlZEtleSIsIm5lc3RlZFZhbHVlcyIsIm5lc3RlZEl0ZW0iLCJuZXN0ZWRWYWx1ZSIsImNvbmNhdCIsInJlc3VsdCIsImFsbFZhbHVlcyIsImdldEtleUF0dHJpYnV0ZXMiLCJpdGVtVmFsdWVzIiwiZGVmYXVsdEtleUF0dHJpYnV0ZXMiLCJJbmZpbml0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/match-sorter/dist/match-sorter.esm.js\n");

/***/ })

};
;